{"componentChunkName":"component---src-templates-blog-post-js","path":"/docker-cheatsheet/","result":{"data":{"site":{"siteMetadata":{"title":"Rahul's Blog"}},"markdownRemark":{"id":"eaa71529-6f16-5fb2-9511-2354643fe0d3","excerpt":"What is docker? Docker is a tool that allows developers, sys-admins etc. to easily deploy their applications in a sandbox (called containers) to run on the host…","html":"<p align=\"center\">\n<img src=\"https://devicons.github.io/devicon/devicon.git/icons/docker/docker-original-wordmark.svg\" width=\"200\" alt=\"docker rahuldkjain\">\n</p>\n<h1>What is docker?</h1>\n<p>Docker is a tool that allows developers, sys-admins etc. to easily deploy their applications in a sandbox (called containers) to run on the host operating system i.e. Linux. The key benefit of Docker is that it allows users to package an application with all of its dependencies into a standardized unit for software development. Unlike virtual machines, containers do not have high overhead and hence enable more efficient usage of the underlying system and resources.</p>\n<h1>What are containers?</h1>\n<p>The industry standard today is to use Virtual Machines (VMs) to run software applications. VMs run applications inside a guest Operating System, which runs on virtual hardware powered by the server’s host OS.</p>\n<p>VMs are great at providing full process isolation for applications: there are very few ways a problem in the host operating system can affect the software running in the guest operating system, and vice-versa. But this isolation comes at great cost — the computational overhead spent virtualizing hardware for a guest OS to use is substantial.</p>\n<p>Containers take a different approach: by leveraging the low-level mechanics of the host operating system, containers provide most of the isolation of virtual machines at a fraction of the computing power.</p>\n<h2>Install Docker</h2>\n<p>The best article to install and configure docker</p>\n<p><a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04\">https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04</a></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># verify cli can talk to engine\n$ sudo docker version\n\n# most config values of engine\n$ sudo docker info </code></pre></div>\n<h2>Docker Command format</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker &lt;command&gt; &lt;sub-command&gt; (options)</code></pre></div>\n<h2>Image Vs Container</h2>\n<p><strong>Image</strong> is the application we want to to run</p>\n<p><strong>Container</strong> is an instance of that image running as a process</p>\n<p>We can have many containers running off the same image.</p>\n<p>Docker’s default image <code class=\"language-text\">registry</code> is called Docker Hub (hub.docker.com)</p>\n<h2>Creating Docker Container</h2>\n<p>Will be using simple nginx web server as image</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run --publish 80:80 nginx</code></pre></div>\n<ul>\n<li>It downloaded image <code class=\"language-text\">nginx</code> from docker hub.</li>\n<li>Started a new container from that image.</li>\n<li>Opened port 80 on the host IP.</li>\n<li>Routes that traffic to the container IP, port 80.</li>\n</ul>\n<p>open <code class=\"language-text\">localhost</code> in the browser to check nginx</p>\n<h2>To run it in the background</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run --publish 80:80 --detach nginx\n# or \n$ sudo docker container run --name mongo -d mongo</code></pre></div>\n<h2>To list containers</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container ls</code></pre></div>\n<h2>To stop container</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container stop &lt;container-id&gt;</code></pre></div>\n<p>No need to put the full <strong>container-id</strong>. Just put enough so that it becomes unqiue to identify</p>\n<h2>To start container</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container start &lt;container-name&gt;</code></pre></div>\n<h2>To get the history of all containers</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container ls -a</code></pre></div>\n<h2>Giving name to the container manually</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run --publish 80:80 --detach --name &lt;container-name&gt; &lt;image&gt;</code></pre></div>\n<h2>See the logs</h2>\n<p>Since, the container running in the background, we can’t see the logs.\nTo see it run the command</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container logs &lt;container-name&gt;</code></pre></div>\n<h2>See the Process running inside the container</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container top &lt;docker-name&gt;</code></pre></div>\n<h2>Remove containers in a single command</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container rm &lt;container-id&gt; &lt;container-id&gt; ..</code></pre></div>\n<p>You cannot remove the running container, so you will get an error like this\n<code class=\"language-text\">Error response from daemon: You cannot remove a running container f0b6dd04ba5f691115f2e0ad3cc4c506483ec3dd4a52e4c63b9bce23c8cfbba5. Stop the container before attempting removal or force remove</code></p>\n<p><strong>To force remove the container</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container rm if &lt;container-id&gt; &lt;container-id&gt; ..</code></pre></div>\n<h1>What happens in docker container run?</h1>\n<ol>\n<li>Looks for that image locally in image cache, doesn’t find anything</li>\n<li>Then looks in remote image repository (defaults to docker hub)</li>\n<li>Downloads the latest version by default</li>\n<li>Creates new container based on that image and prepares to start</li>\n<li>Gives it a virtual IP on a private network inside docker engine</li>\n<li>Opens up port 80 on host and forwards to port 80 in container</li>\n<li>Starts container by using the CMD in the image dockerfile</li>\n</ol>\n<h3>Examples of changing the defaults</h3>\n<h6>change host listening port</h6>\n<p><code class=\"language-text\">8080:80</code></p>\n<h6>change version of image</h6>\n<p><code class=\"language-text\">nginx:1.11</code></p>\n<h6>change CMD run on start</h6>\n<p><code class=\"language-text\">-T</code></p>\n<p><strong>Complete command</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run --publish 8080:80 &lt;container-name&gt; -d nginx:1.11 nginx -T</code></pre></div>\n<blockquote>\n<p>Containers aren’t just Virtual Machine</p>\n</blockquote>\n<h2>Traditional way of seeing the processes list</h2>\n<p><code class=\"language-text\">ps aux</code>\n<code class=\"language-text\">ps aux | grep mongo</code></p>\n<h2>MySQL Container</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run -d --name mysql -e MYSQL_RANDOM_ROOT_PASSWORD=true mysql</code></pre></div>\n<h2>Inspect the config of containers</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container inspect</code></pre></div>\n<h2>Live stats of containers</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container stats</code></pre></div>\n<p><strong>Summary</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># process list in one container\n$ sudo docker container top\n\n# details of one container config\n$ sudo docker container inspect\n\n# performance stats for all containers\n$ sudo docker container stats</code></pre></div>\n<h2>Run container interactively (in terminal)</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run -it --name proxy nginx bash</code></pre></div>\n<p>To get out of the shell (it will stop the container)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@container-id:/# exit</code></pre></div>\n<h2>Ubuntu Container</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run -it --name ubuntu ubuntu</code></pre></div>\n<h2>To start interactive container again</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container start -ai &lt;container-name&gt;</code></pre></div>\n<h2>Run additional process in running container</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo container exec -it &lt;container-name&gt; bash</code></pre></div>\n<p><strong>NOTE</strong>: If you exit from it, it won’t stop the container</p>\n<h1>Download docker images locally</h1>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker pull &lt;image-name&gt;</code></pre></div>\n<p><strong>List existing local docker images</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker image ls</code></pre></div>\n<h2>Alpine distro</h2>\n<ul>\n<li>Alpine is a small linux distro (~4MB in size)</li>\n<li>It does not even has bash installed in it</li>\n<li>\n<p>but it has sh installed</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker pull alpine\n$ sudo docker container run -it alpine sh</code></pre></div>\n</li>\n</ul>\n<p><strong>Summary</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># start new container interactively\n$ sudo docker container run -it\n\n# run additional command in existing container\n$ sudo docker container exec -it</code></pre></div>\n<h1>Docker Network Concepts</h1>\n<ul>\n<li>Each container connected to a private virtual network <code class=\"language-text\">bridge</code></li>\n<li>Each virtual network routes through NAT Firewall on host IP</li>\n<li>All containers in a virtual network can talk to each other without -p</li>\n<li>Best practice is to create a new virtual network for each app</li>\n<li>“Batteries included, but removable”</li>\n<li>can attach containers to more than one virtual network (or none)</li>\n<li>skip virtual networks and use host IP (—net=host)</li>\n<li>use different docker network drivers to gain new abilities</li>\n</ul>\n<h2>-p (—publish)</h2>\n<p>Publishing ports is always in HOST:CONTAINER format</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run -p 80:80 --name webhost -d nginx</code></pre></div>\n<h3>Container port</h3>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container port &lt;container-name&gt;</code></pre></div>\n<p>It will look like that the container is using the local IP Address but its not.\nTo get the  IP Address of the container</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container inspect --format &#39;{{ .NetworkSettings.IPAddress }}&#39; &lt;container-name&gt;</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># Output\n172.17.0.2</code></pre></div>\n<p>But its not same as your IP address</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ ifconfig</code></pre></div>\n<p>You will see that its different network\n<code class=\"language-text\">docker0</code>: is the virtual network that can talk to your host/network </p>\n<ul>\n<li>We can have many virtual networks for dockers</li>\n<li>containers in the same virtual network can talk to each other</li>\n<li>container needs to publish (<strong>-p HOST:CONTAINER</strong>) to communicate with the host/machine-network</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">c1(-p 80:80)/docker0 -&gt; host\nc2/docker0 -&gt; host\n\nc1/docker1 -&gt; host\nc2(-p 8080:80)/docker1 -&gt; host</code></pre></div>\n<h1>Docker Networks: CLI Management</h1>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\"># show networks\n$ sudo docker network ls\n\n# inspect a network\n$ sudo docker network inspect\n\n# create a network\n$ sudo docker network create --driver\n\n# attach a network to container\n$ sudo docker network connect\n\n# detach a network from container\n$ sudo docker network disconnect </code></pre></div>\n<h3>3 Network drivers</h3>\n<ol>\n<li>bridge</li>\n<li>host</li>\n<li>none</li>\n</ol>\n<p><strong>bridge = docker0</strong></p>\n<p><code class=\"language-text\">--network bridge</code>: default docker virtual network which is NAT’ed behind the host IP</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network inspect bridge</code></pre></div>\n<p><code class=\"language-text\">--network host</code>: it gains performance by skipping virtual networks but sacrifices security of container mode\nIt prevents security boundary of containers</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network inspect host</code></pre></div>\n<h2>Create docker network</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network create &lt;network-name&gt;</code></pre></div>\n<p>A new network with <code class=\"language-text\">bridge</code> driver as default will be created\nCheck: </p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network ls</code></pre></div>\n<h2>Run a container in a docker network</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container run -d --name &lt;container-name&gt; --network &lt;network-name&gt; nginx</code></pre></div>\n<p>Check:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network inspect &lt;network-name&gt;</code></pre></div>\n<p>A Container can be on different networks at the same time</p>\n<h2>Connect container</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network connect &lt;network-id&gt; &lt;container-id&gt;</code></pre></div>\n<p>check: </p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network inspect &lt;network-id&gt;</code></pre></div>\n<h2>Disconnect container</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network disconnect &lt;network-id&gt; &lt;container-id&gt;</code></pre></div>\n<p>check: </p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker network inspect &lt;network-id&gt;</code></pre></div>\n<h1>Docker Networks: Default Security</h1>\n<ul>\n<li>create your apps on frontend/backend sit on the same docker network</li>\n<li>their inter-communication never leaves host</li>\n<li>All externally exposed ports closed by default</li>\n<li>You must manually expose via -p, which is better default security</li>\n<li>This gets even better with Swarn &#x26; Overlay Networks</li>\n</ul>\n<h1>Docker Networks: DNS</h1>\n<p>How containers find each other?</p>\n<ul>\n<li>understand how DNS is the key to easy inter-container comms</li>\n<li>see how it works by default with custom networks</li>\n<li>learn how to use <code class=\"language-text\">--link</code> to enable DNS on default bridge network</li>\n</ul>\n<h4>Forget IPs</h4>\n<p>static IP’s and using IP’s for talking to containers is an antipatern. Do your best to avoid it</p>\n<h4>Docker DNS</h4>\n<p>Docker daemon has a built-in DNS Server that containers use by default</p>\n<h4>DNS Default Names</h4>\n<p>Docker defaults the hostname to the container’s name, but you can also set aliases</p>\n<p>Check: </p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container exec -it &lt;container1-name&gt; ping &lt;container2-name&gt;</code></pre></div>\n<p>If this won’t run and an error like <code class=\"language-text\">starting container process caused &quot;exec: \\&quot;ping\\&quot;: executable file not found in $PATH&quot;: unknown</code> comes up then it means that ping is not installed in the container</p>\n<p>Install ping like this</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$ sudo docker container exec -it &lt;container-name&gt; bash\napt-get update\napt-get install iputils-ping</code></pre></div>\n<p>Then run the above command, it will work fine</p>\n<p>No need to specify specific IP Address. It works absolutely fine with names</p>\n<ul>\n<li>containers shouldn’t rely on IP’s for inter-communication</li>\n<li>DNS for friendly names is built-in if you use custom networks</li>\n</ul>","frontmatter":{"title":"Docker Cheatsheet","date":"July 30, 2020","description":"Learn what is docker, containers, images and how to install it. How to create, run and execute docker containers using command line interface(CLI)"}}},"pageContext":{"slug":"/docker-cheatsheet/","previous":{"fields":{"slug":"/git/push-specific-changes-to-master/"},"frontmatter":{"title":"Merge a specific change with master, following the master-develop-features git structure"}},"next":{"fields":{"slug":"/bash-useful-commands/"},"frontmatter":{"title":"Bash Useful Commands"}}}}}